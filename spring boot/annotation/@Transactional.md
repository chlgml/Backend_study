## @Transactional

트랜잭션 처리를 지원한다. 

- 트랜잭션이란?

  네이버에서 한번쯤 구매를 해본 기억이 있었을 것이다. 네이버는 사기를 방지하기 위해 구매자가 네이버에 돈을 보내게 되면 바로 판매자에게 돈이 가지 않고 네이버가 가지고 있다가 구매자가 물건을 받고 확인하면 구매 확정이 되어 판매자에게 수입금이 가는 구조이다. 만약 구매자가 입금을 했는데 물건이 잘못 배송이 와서 반품을 하게 되면 돈은 다시 구매자에게 간다. 

  정리하자면, 데이터베이스를 다룰 때 트랜잭션을 적용하면 데이터 추가, 갱신, 삭제 등으로 이루어진 작업을 처리하던 도중 오류가 발생하면, 모든 작업들을 원상태로 되돌릴 수 있다. 모든 작업들이 성공해야만 데이터베이스에 반영된다.



- 데이터베이스의 상태를 변경하는 작업 또는 한번 수행되어야 하는 연산들을 의미함.
- begin, commit을 자동으로 수행해준다.
  - commit
    - 모든 작업을 정상적으로 처리하겠다고 확정하는 명령어
    - 트랜젝션의 처리 과정을 데이터베이스에 반영하기 위해 변령된 내용을 영구 저장
    - commit 수행하면, 하나의 트랜젝션 과정을 종료하게 된다.
- 예외 발생시 rollback 처리를 자동으로 수행해준다.
  - rollback
    - 작업중 문제가 발생했을 때, 트랜젝션의 처리 과정에서 발생한 변경사항을 취소하고, 트랜젝션 과정을 종료시킨다.
    - 트랜젝션으로 인한 하나의 묶음 처리가 시작되기 이전의 상태로 되돌린다.
    - 트랜텍션 작업 중 하나라도 문제가 발생하면, 모든 작업을 취소해야 하기 때문에 하나의 논리적인 작업 단위로 구성해 놓아야 함.
    - 자동 ROLLBACK되는 경우
      - 비정상 종료가 되거나 정전, 컴퓨터가 다운된 경우

```
COMMIT 명령어와 ROLLBACK 명령어의 장점
- 데이터의 무결성이 보장된다.
- 영구적으로 변경하기 전에 데이터의 변경사항 확인 가능
- 논리적으로 연관된 작업을 그룹화 할 수 있음
```

- 4가지 성질
  - 원자성 : 한 트랜젝션 내에 실행한 작업은 하나의 단위로 처리 (한 부분이 실패해도 모두 실패)
  - 일관성 : 트랜잭션은 일관성 있는 데이터베이스 상태를 유지
  - 격리성 : 동시에 실행되는 트랜잭션들이 서로 영향을 받지 않도록 격리해야함.
  - 영속성 : 트랜젝션을 성공적으로 마치면 결과가 항상 저장되어야 함.
- @Transactional어노테이션을 붙이면 적용된 범위에서는 트랜잭션 기능이 포함된 프록시 객체가 생성되어 commit 혹은 rollback을 실행



**@Transactional 옵션**

- isolation : 트랜택션에서 일관성 없는 데이터의 허용 수준 설정

  ```java
  @Transactional(isolation = Isolation.DEFAULT) // 이런식으로 설정하면 된다
  ```

  - DEFAULT (Defualt) : 기본이며, DB의  lsolation Level을 따른다.
  - READ_UNCOMMITED (level 0) : 데이터를 변경하는 동안 다른 사용자는 아직 완료되지 않은 데이터를 읽을 수 있다.
  - READ_COMMITED (level 1)  : 데이터를 변경하는 동안 다른 사용자는 해당 데이터 접근 불가
  - REPEATEABLE_READ (level 2)  : 동일한 필드에 대해 다중 접근 시 모두 동일한 결과를 보장
  - SERIALIZABLE (level 3)  : 가장 높은 격리 단계고 성능 저하의 우려가 있다.

  ```
  레벨이 높아질수록 데이터의 무결성을 유지할 수 있지만, 상위레벨을 사용하면 DB의 성능이 떨어지며, 비용이 높아진다.
  최대한 효율적인 방안을 찾아 상황에 맞게 알맞게 사용하는 것이 중요함.
  ```

- propagation: 트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 지정하는 옵션

  ```java
  @Transactional(propagation=Propagation.REQUIRED) // 이런식으로 설정하면 된다
  ```

  - REQUIRED (Defualt) : 징행중인 트랜잭션이 있다면 해당 트랜잭션의 속성을 따르고, 진행중이 아닐경우 새로운 트랜잭션 생성
  - REQUIRES_NEW : 항상 새로운 트랜잭션 생성. 실행중인 트랜잭션이 있다면 보류하고 해당 트랜잭션 작업 진행
  - SUPPORT : 이미 진행중인 트랜잭션 속성을 따르고 없다면 트랜잭션 설정하지 않음
  - NOT_SUPPORT : 이미 진행중인 트래잭션이 있다면 보류, 트랜잭셥 없이 작업 수행
  - MANDATORY : 이미 진행중인 트랜잭션이 있어야함 작업 수행, 없으면 예외 발생
  - NEVER : 트랜잭션이 진행중이지 않을때 작업 수행, 트랜잭션이 있다면 예외 발생
  - NESTED : 진행중인 트랜잭션이 있다면 중첩된 트랜잭션이 실행됨, 존재하지 않으면 REQUIRED와 동일하게 실행

- noRollbackFor : 특정예외 발생 시 Rollback 처리 하지 않음.

  ```java
  @Transactional(noRollbackFor=Exception.class)
  ```

- rollbackFor : 특정 예외가 발생시 강제로 rollback한다.

  ```java
  @Transactional(rollbackFor = Exception.class)
  // 롤백을 하기 위해서는 위와 같이 적어주어야함
  ```

  @Transactional 기본적으로 Unchecked Exception, Error만을 rollback하고 있기 때문에 모든 예외를 rollback하고 싶다면 위처럼 설정 해 주어야 한다.

- timeout : 지정한 시간 내에 매소드가 수행되지 않으면 rollback함

  ```java
  @Transactional(timeout=10)
  ```

- readOnly : 트랜잭션을 읽기 전용으로 설정

  - true시 insert, update, delete실행시 예외 발생
  - Default = flase